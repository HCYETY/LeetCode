### 大数打印
1. 大数打印首先要考虑到它的变量类型：
- 无论是 short / int / long ... 任意变量类型，数字的取值范围都是有限的。因此，大数的表示应用字符串 String 类型。
2. 生成数字的字符串集：
- 使用 int 类型时，每轮可通过 +1+1 生成下个数字，而此方法无法应用至 String 类型。并且， String 类型的数字的进位操作效率较低，例如 "9999" 至 "10000" 需要从个位到千位循环判断，进位 4 次。
- 观察可知，生成的列表实际上是 n 位 0 - 9 的 全排列 ，因此可避开进位操作，通过递归生成数字的 String 列表。
3. 递归生成全排列：
- 基于分治算法的思想，先固定高位，向低位递归，当个位已被固定时，添加数字的字符串。 例如当 n=2 时（数字范围 1 - 99 ），固定十位为 0 - 9 ，按顺序依次开启递归，固定个位 00 - 99 ，终止递归并添加数字字符串。

在此方法下，各数字字符串被逗号隔开，共同组成长字符串。返回的数字集字符串如下所示：   
输入：n = 1   
输出："0,1,2,3,4,5,6,7,8,9"

输入：n = 2   
输出："00,01,02,...,10,11,12,...,97,98,99"

输入：n = 3   
输出："000,001,002,...,100,101,102,...,997,998,999"

观察可知，当前的生成方法仍有以下问题：   
1）. 诸如 00, 01, 02, ⋯ 应显示为 0, 1, 2, ⋯ ，即应 删除高位多余的 0 
2）. 此方法从 0 开始生成，而题目要求 列表从 1 开始 

以上两个问题的解决方法如下：   
1）. 删除高位多余的 0 ：   
- 字符串左边界定义： 声明变量 start 规定字符串的左边界，以保证添加的数字字符串 num[start:] 中无高位多余的 0 。例如当 n = 2 时， 1 ~ 9 时 start = 1 ， 10 ~ 99 时 start = 0 。
- 左边界 start 变化规律： 观察可知，当输出数字的所有位都是 9 时，则下个数字需要向更高位进 1 ，此时左边界 start 需要减 1 （即高位多余的 0 减少一个）。例如当 n = 3 （数字范围 1 ~ 999 ）时，左边界 start 需要减 1 的情况有： "009" 进位至 "010" ， "099" 进位至 "100" 。设数字各位中 9 的数量为 nine ，所有位都为 9 的判断条件可用以下公式表示：
n - start = nine
- 统计 nine 的方法： 固定第 xx 位时，当 i = 9 则执行 nine = nine + 1 ，并在回溯前恢复 nine = nine - 1 。   

2）. 列表从 1 开始：
- 在以上方法的基础上，添加数字字符串前判断其是否为 "0" ，若为 "0" 则直接跳过。
```
//java 
public void printNumbers(int n) { 
        //声明字符数组,用来存放一个大数 
        char[] number = new char[n]; 
        Arrays.fill(number, '0'); 
        while (!incrementNumber(number)) { 
            saveNumber(number); //存储数值 
        } 
    }

    private boolean incrementNumber(char[] number) {
        //循环体退出标识
        boolean isBreak = false;
        //进位标识
        int carryFlag = 0;
        int l = number.length;
        for (int i = l - 1; i >= 0; i--) {
            //取第i位的数字转化位int
            int nSum = number[i] - '0' + carryFlag;
            if (i == l - 1) {
                //最低位加1
                ++nSum;
            }
            if (nSum >= 10) {
                if (i == 0) {
                    isBreak = true;
                } else {
                    //进位之后减10，并把进位标识设置为1
                    nSum -= 10;
                    carryFlag = 1;
                    number[i] = (char) ('0' + nSum);
                }
            } else {
                number[i] = (char) (nSum + '0');
                break;
            }
        }
        return isBreak;
    }
    private void saveNumber(char[] number) {
        boolean isBegin0 = true;
        for (char c : number) {
            if (isBegin0 && c != '0') {
                isBegin0 = false;
            }
            if (!isBegin0) {
                // 到这里并没有继续往下实现一个存储数组的版本，是因为原题其实就是要求打印数值。
                // 这道题目在leetcode上被改动成返回int数组的形式，也只是为了测试方便，
                // 本身leetcode并没有提供对应的大数测试样例，也是担心其内存溢出。
                // 总之大家知道本题的考察点所在就可以了。
                System.out.print(c);
            }
        }
        System.out.println();
    }
```
> 推荐学习资料：[小浩算法之大数打印](https://www.geekxh.com/1.3.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B3%BB%E5%88%97/304.html#_04%E3%80%81%E9%A2%98%E7%9B%AE%E7%BB%A7%E7%BB%AD%E5%8D%87%E7%BA%A7)
---
### 进制转换
1. 十进制转二进制
```
/**
 * @name 十进制转二进制
 * @param {number} N 需要转换的数字
 * @return {string} 返回二进制字符串
 */
const decimalToBinary = (N) => {
  let result = '';
  while (N > 0) {
    result = N % 2 + result;
    N = Math.floor(N / 2);
  }
  return result;
}
console.log(decimalToBinary(6)); // 110
```
---
### 位运算
1. 各符号概念

|符号|描述|运算规则|举例|
|:--:|:--:|:--:|:--:|
|&|与|两个位都为1时，结果才为1|0&0=0&nbsp;&nbsp;&nbsp;0&1=0&nbsp;&nbsp;&nbsp;1&0=0&nbsp;&nbsp;&nbsp;1&1=1<br>x&0=0&nbsp;&nbsp;&nbsp;x&1=x&nbsp;&nbsp;&nbsp;x&x=x
|\||或|两个位都为0时，结果才为0|0\|0=0&nbsp;&nbsp;&nbsp;0\|1=1&nbsp;&nbsp;&nbsp;1\|0=1&nbsp;&nbsp;&nbsp;1\|1=1<br>x\|0=x&nbsp;&nbsp;&nbsp;x\|1=1&nbsp;&nbsp;&nbsp;x\|x=x
|^|异或|两个位相同为0，相异为1|0^0=0&nbsp;&nbsp;&nbsp;0^1=1&nbsp;&nbsp;&nbsp;1^0=1&nbsp;&nbsp;&nbsp;1^1=0<br>x^x=0&nbsp;&nbsp;&nbsp;x^0=x&nbsp;&nbsp;&nbsp;x^1=~x
|~|取反|0变1，1变0|~1=0&nbsp;&nbsp;&nbsp;~0=1
|<<|左移|将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。**若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2**|设 a=1010 1110，a = a<< 2 将a的二进制位左移2位、右补0，即得a=1011 1000
|>>|右移|将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。**操作数每右移一位，相当于该数除以2**|设a = 111011，a >>= 1 (表示向右移动一位，>>>表示无符号右移,-7右移动1会变成3，>>表示有符号右移) a 的值变为 11101 
2. 各运算符用途
- &与运算：
    - 1、清零。&nbsp;如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。
    - 2、取一个数的指定位。&nbsp;比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&Y=0000 1110）即可得到X的指定位。
    - 3、判断奇偶。&nbsp;只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。
- |或运算：
    - 常用来对一个数据的某些位设置为1。&nbsp;比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。
- ^异或运算（用的最多）:
    - 几条性质:
        - 1、交换律
        - 2、结合律 (a^b)^c == a^(b^c)
        - 3、对于任何数x，都有 x^x=0，x^0=x
        - 4、自反性: a^b^b=a^0=a;
    - 用途：
        - 1、翻转指定位。<br>比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。
        - 2、加密。
            - ①明文（text）与密钥（key）进行异或运算，可以得到密文（cipherText）。
            ```
            text ^ key = cipherText
            ```
            - ②密文与密钥再次进行异或运算，就可以还原成明文。
            ```
            cipherText ^ key = text
            ```
            - 原理：如果明文是 x，密钥是 y，那么 x 连续与 y 进行两次异或运算，得到自身。
            ```
            (x ^ y) ^ y
            = x ^ (y ^ y)
            = x ^ 0
            = x
            ```
        - 3、交换两个数。两个变量连续进行三次异或运算，可以互相交换值。<br>假设两个变量是 a 和 b ，各自的值是 x 和 y 。下面就是 a 和 b 进行三次异或运算，注释部分是每次运算后两个变量的值。
            ```
            void Swap(int &a, int &b){
                if (a != b){
                    a ^= b; // (x^y, y)
                    b ^= a; // (x^y, x^y^y) => (x^y, x)
                    a ^= b; // (x^y^x, x) => (y, x)
                }
            }
            ```
            **这是两个变量交换值的最快方法，不需要任何额外的空间。**
    > [异或运算 XOR 教程](https://www.ruanyifeng.com/blog/2021/01/_xor.html)
- ~取反运算：
    - 使一个数的最低位为零。&nbsp;使a的最低位为0，可以表示为：a & ~1。~1的值为 1111 1111 1111 1110，再按"与"运算，最低位一定为0。因为“ ~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。
---
### 